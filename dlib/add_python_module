# This is a CMake file that sets up the add_python_module() macro.  This macro
# lets you easily make python modules that use dlib.  
#
# The macro takes the module name as its first argument and then a list of
# source files to compile into the module.  See ../tools/python/CMakeLists.txt
# for an example.

set(CMAKE_PREFIX_PATH ${CMAKE_PREFIX_PATH} 
        " C:/Program Files(x86)/boost/boost_1_*"  
        " C:/Program Files/boost/boost_1_*" )

#SET(Boost_USE_STATIC_LIBS OFF)
#SET(Boost_USE_MULTITHREADED ON)
#SET(Boost_USE_STATIC_RUNTIME OFF)

FIND_PACKAGE(Boost 1.41.0 COMPONENTS python REQUIRED)
FIND_PACKAGE(PythonLibs 2.6 REQUIRED)


INCLUDE_DIRECTORIES("${Boost_INCLUDE_DIRS}")
if (PYTHON_INCLUDE_PATH)
   INCLUDE_DIRECTORIES("${PYTHON_INCLUDE_PATH}" )
else()
   INCLUDE_DIRECTORIES("${PYTHON_INCLUDE_DIRS}" )
endif()

if (CMAKE_COMPILER_IS_GNUCXX)
   add_definitions("-fPIC")
endif()

# include dlib so we can link against it
string(REPLACE "add_python_module" "" dlib_path ${CMAKE_CURRENT_LIST_FILE})
include(${dlib_path}/cmake)


# We put the extra _ on the end of the name just so it's possible to
# have a module name of dlib and not get a conflict with the target named
# dlib in ../dlib/cmake.  We use the target OUPUT_NAME property to ensure the
# output name is set to what the user asked for (i.e. no _).
macro(add_python_module module_name module_sources )
   ADD_LIBRARY(${module_name}_ SHARED ${module_sources} ${ARGN} )
   TARGET_LINK_LIBRARIES(${module_name}_ ${Boost_LIBRARIES}  dlib)
   if(WIN32)
      SET_TARGET_PROPERTIES( ${module_name}_
         PROPERTIES
         PREFIX ""
         SUFFIX ".pyd"
         OUTPUT_NAME ${module_name}
         )
   else()
      SET_TARGET_PROPERTIES( ${module_name}_
         PROPERTIES
         PREFIX ""
         OUTPUT_NAME ${module_name}
         )
   endif()
endmacro()

